<!DOCTYPE html>
<html>

  <head>
    <meta charset="utf-8">
    <title>Unluckyless 博客</title>
    <link rel="icon" href="../../../img/闪耀狗头.jpg" type="image/jpg">
    <link rel="stylesheet" href="../../../css/unit.css">
    <link rel="stylesheet" href="../../../css/content.css">

  </head>

  <body>

    <div class="header" id="header">
      <div class="header-left">
        <div class="logo">
          <a href="../../../index.html">
            <img src="../../../img/闪耀狗头.jpg" alt="Website Logo" class="navbar-logo">
          </a>
        </div>
        <div class="name">
          <h3>Unluckyless' Blog</h3>
        </div>
      </div>
      <div class="nav">
        <ul>
          <li class="active">
            <a href="../../../index.html">首页</a>
          </li>
          <li>
            <a href="">gitee</a>
          </li>
        </ul>
      </div>
    </div>


    <!-- layout.html -->
    <div id="box">
      <div id="content">
        <h1>CMake教程</h1>
        <h1>1.CMake 概述</h1>
        <p>CMake 是一个项目构建工具，并且是跨平台的。关于项目构建还有Makefile（通过make命令进行项目构建），大多数IDE软件都集成了make，比如：VS的make，Linux下的GNU make等，如果自己动手写makefile，会发现，makefile通常依赖于当前的编译平台，而且编写makefile的工作量比较大，解决依赖关系时也容易出错。</p>
        <p>而CMake恰好能解决上述问题，其允许开发者指定整个工程的编译流程，再根据编译平台，<code>自动生成本地化的Makefile和工程文件</code>，最后用户只需<code>make</code>编译即可，所以可以吧CMake看成一款自动生成Makefile的工具，其编译流程如下图</p>
        <p><img src="../resource/1.png" alt="Untitled"></p>
        <ul>
          <li>蓝色虚线表示使用<code>makefile</code> 构建项目的过程</li>
          <li>红色实线表示使用<code>cmake</code> 构建项目的过程</li>
        </ul>
        <p>介绍完CMake的作用之后，再来总结一下它的有点：</p>
        <ul>
          <li>跨平台</li>
          <li>能够管理大型项目</li>
          <li>简化编译构建的过程和编译过程</li>
          <li>可扩展：可以为cmake编写特定功能的模块，扩充cmake功能</li>
        </ul>
        <h1>2.CMake的使用</h1>
        <p><code>Cmake</code> 支持大写、小写、混合大小写的命令。如果在编写<code>CMakeLists.txt</code> 文件时使用的工具有对应的命令提示，那么大小写随缘即可，不要太过在意。</p>
        <h2>2.1 注释</h2>
        <h3>2.1.1 行注释</h3>
        <p><code>CMake</code> 使用<code>#</code> 进行<code>行注释</code> ，可以放在任意位置</p>
        <pre><code class="language-c"># 这是一个 CMakeLists.txt 文件
cmake_minimum_required(VERSION 3.0.0)
</code></pre>
        <h3>2.1.2 块注释</h3>
        <p><code>Cmake</code> 使用<code>#[[]]</code> 形式进行<code>块注释</code> 。</p>
        <pre><code class="language-c">#[[ 这是一个 CMakeLists.txt 文件。
这是一个 CMakeLists.txt 文件
这是一个 CMakeLists.txt 文件]]
cmake_minimum_required(VERSION 3.0.0)
</code></pre>
        <h2>2.2 只有源文件</h2>
        <h3>2.2.1 共处一室</h3>
        <ol>
          <li>准备工作，准备了几个测试文件</li>
        </ol>
        <ul>
          <li>add.cpp</li>
        </ul>
        <pre><code class="language-cpp">#include &lt;stdio.h&gt;
#include "head.h"

int add(int a, int b)
{
    return a+b;
}
</code></pre>
        <ul>
          <li>sub.cpp</li>
        </ul>
        <pre><code class="language-cpp">#include &lt;stdio.h&gt;
#include "head.h"

int subtract(int a, int b)
{
    return a-b;
}
</code></pre>
        <ul>
          <li>mult.cpp</li>
        </ul>
        <pre><code class="language-cpp">#include &lt;stdio.h&gt;
#include "head.h"

int multiply(int a, int b)
{
    return a*b;
}
</code></pre>
        <ul>
          <li>div.cpp</li>
        </ul>
        <pre><code class="language-cpp">#include &lt;stdio.h&gt;
#include "head.h"

double divide(int a, int b)
{
    return (double)a/b;
}
</code></pre>
        <ul>
          <li>head.h</li>
        </ul>
        <pre><code class="language-cpp">#ifndef _HEAD_H
#define _HEAD_H
// 加法
int add(int a, int b);
// 减法
int subtract(int a, int b);
// 乘法
int multiply(int a, int b);
// 除法
double divide(int a, int b);
#endif
</code></pre>
        <ul>
          <li>main.cpp</li>
        </ul>
        <pre><code class="language-cpp">#include &lt;stdio.h&gt;
#include "head.h"

int main()
{
    int a = 20;
    int b = 12;
    printf("a = %d, b = %d\n", a, b);
    printf("a + b = %d\n", add(a, b));
    printf("a - b = %d\n", subtract(a, b));
    printf("a * b = %d\n", multiply(a, b));
    printf("a / b = %f\n", divide(a, b));
    return 0;
}
</code></pre>
        <ol>
          <li>上述文件的目录结构如下：</li>
        </ol>
        <pre><code class="language-bash">$ tree
.
├── add.c
├── div.c
├── head.h
├── main.c
├── mult.c
└── sub.c
</code></pre>
        <ol>
          <li>添加<code>CMakeLists.txt</code> 文件</li>
        </ol>
        <p>在上述源文件所在目录下添加一个新文件CMakeLists.txt，文件内容如下：</p>
        <pre><code class="language-bash">cmake_minimum_required(VERSION 3.0)
project(CALC)
add_executable(app add.c div.c main.c mult.c sub.c)
</code></pre>
        <ul>
          <li>
            <p><code>cmake_minimum_required</code> ：指定使用的cmake最低版本</p>
          </li>
          <li>
            <p><code>project</code> ：定义工程名称，并可指定工程的版本、工程描述、web主页地址、支持的语言（默认情况支持所有语言），如果不需要这些都是可以忽略的，只需要指定出工程名字即可。</p>
            <pre><code class="language-bash"># PROJECT 指令的语法是：
project(&lt;PROJECT-NAME&gt; [&lt;language-name&gt;...])
project(&lt;PROJECT-NAME&gt;
       [VERSION &lt;major&gt;[.&lt;minor&gt;[.&lt;patch&gt;[.&lt;tweak&gt;]]]]
       [DESCRIPTION &lt;project-description-string&gt;]
       [HOMEPAGE_URL &lt;url-string&gt;]
       [LANGUAGES &lt;language-name&gt;...])
</code></pre>
          </li>
          <li>
            <p><code>add_executable</code> ：定义工程会生成一个可执行程序</p>
            <pre><code class="language-bash">add_executable(可执行程序名 源文件名)
</code></pre>
            <ul>
              <li>
                <p>这里的可执行程序名和<code>project</code> 中的项目名没有任何关系</p>
              </li>
              <li>
                <p>源文件名可以是一个也可以是多个，如有多个可用空格或<code>；</code> 间隔</p>
                <pre><code class="language-bash"># 样式1
add_executable(app add.c div.c main.c mult.c sub.c)
# 样式2
add_executable(app add.c;div.c;main.c;mult.c;sub.c)
</code></pre>
              </li>
            </ul>
          </li>
        </ul>
        <ol>
          <li>
            <p>执行<code>CMake</code> 命令</p>
            <p>将CMakeLists.txt文件编辑好之后，就可以执行<code>cmkae</code> 命令了。</p>
            <pre><code class="language-bash"># cmake 命令原型
$ cmake .(CMakeLists.txt文件所在路径)
</code></pre>
            <p>当执行 <code>cmake</code>命令之后，CMakeLists.txt 中的命令就会被执行，所以一定要注意给 <code>cmake</code> 命令指定路径的时候一定不能出错。</p>
            <p>在对应的目录下生成了一个<code>makefile</code> 文件后再执行<code>make</code> 命令即可编译。</p>
            <p>最终可执行程序 <code>app</code> 就被编译出来了（这个名字是在 CMakeLists.txt 中指定的）。</p>
          </li>
        </ol>
        <h3>2.2.2 VIP包房</h3>
        <p>通过上面的例子可以看出，如果在<code>CMakeLists.txt</code> 文件所在目录执行了<code>cmake</code> 命令之后就会生成一些目录和文件（<code>包括 makefile 文件</code>），如果再基于<code>makefile文件</code> 执行<code>make</code> 命令，程序在编译过程中还会生成一些中间文件和一个可执行文件，这样会导致整个项目目录看起来很混乱，不太容易管理和维护，此时可以把生成的这些与项目源码无关的文件统一放到一个对应的目录里面，比如<code>build</code></p>
        <p>现在 <code>cmake</code> 命令是在 <code>build</code> 目录中执行的，但是 CMakeLists.txt 文件是 <code>build</code> 目录的上一级目录中，所以 <code>cmake</code> 命令后指定的路径为<code>..</code>，即当前目录的上一级目录。</p>
        <h2>2.3 私人定制</h2>
        <h3>2.3.1 定义变量</h3>
        <p>在上面的例子中一共提供了5个源文件，假设这五个源文件需要反复被使用，每次直接将他们的名字写出来确实很麻烦，此时我们就需要定义一个变量，将文件名对应的字符串存储起来，在cmake里定义变量需要使用<code>set</code> 。</p>
        <pre><code class="language-bash"># SET 指令的语法是：
# [] 中的参数为可选项, 如不需要可以不写
SET(VAR [VALUE] [CACHE TYPE DOCSTRING [FORCE]])
</code></pre>
        <ul>
          <li><code>VAR</code> ：变量名</li>
          <li><code>VALUE</code> ：变量值</li>
        </ul>
        <pre><code class="language-bash"># 方式1: 各个源文件之间使用空格间隔
# set(SRC_LIST add.c  div.c   main.c  mult.c  sub.c)

# 方式2: 各个源文件之间使用分号 ; 间隔
set(SRC_LIST add.c;div.c;main.c;mult.c;sub.c)
add_executable(app  ${SRC_LIST})
</code></pre>
        <h3>2.3.2 指定使用的C++标准</h3>
        <p>在编写C++程序时，可能会用到C++11、C++14、C++17、C++20等新特性，那么需要再编译的时候再在编译命令中制定出要使用哪个标准：</p>
        <pre><code class="language-bash">$ g++ *.cpp -std=c++11 -o app
</code></pre>
        <p>上面的例子中通过参数<code>-std=c++11</code> 指定出要使用C++11标准编译程序，C++标准对应有一宏叫做<code>CMAKE_CXX_STANDARD</code> 。在CMake中想要指定C++标准有两种方式：</p>
        <ol>
          <li>在CMakeLists.txt中通过set命令指定</li>
        </ol>
        <pre><code class="language-bash">#增加-std=c++11
set(CMAKE_CXX_STANDARD 11)
#增加-std=c++14
set(CMAKE_CXX_STANDARD 14)
#增加-std=c++17
set(CMAKE_CXX_STANDARD 17)
</code></pre>
        <ol>
          <li>在执行cmkae命令时指定出这个宏的值</li>
        </ol>
        <pre><code class="language-bash">#增加-std=c++11
set(CMAKE_CXX_STANDARD 11)
#增加-std=c++14
set(CMAKE_CXX_STANDARD 14)
#增加-std=c++17
set(CMAKE_CXX_STANDARD 17)
</code></pre>
        <h3>2.3.3 指定输出的路径</h3>
        <p>在CMake中指定可执行程序输出的路径，也对应一个宏，叫做<code>EXTCUTABLE_OUTPUT_PATH</code> ，它的值还是通过<code>set</code> 命令进行设置：</p>
        <pre><code class="language-bash">set(HOME /home/unluckyless/workSpace/learningNOTE/CMake/example)
set(EXECUTABLE_OUTPUT_PATH ${HOME})
</code></pre>
        <ul>
          <li>第一行：定义一个变量用于存储一个绝对路径</li>
          <li>第二行：将拼接好的路径值设置给<code>EXTCUTABLE_OUTPUT_PATH</code> 宏
            <ul>
              <li>如果在这个路径中子目录不存在，会自动生成，无需自己手动创建</li>
            </ul>
          </li>
        </ul>
        <p>由于可执行程序是基于cmake命令生成的makefile文件然后再执行<code>make</code> 命令得到的，所以如果此处指定可执行程序生成路径的时候使用的是相对路径 ./xxx/xxx，那么这个路径中的./对应的是makefile文件所在的目录。</p>
        <h2>2.4 搜索文件</h2>
        <p>如果一个项目里面的源文件很多吗，在编写<code>CMakeLists.txt</code> 文件时不可能将项目目录的各个文件一一罗列出来，这样太麻烦也不现实。所以CMake中提供了搜索文件的命令，可以使用<code>aux_source_directory</code> 命令或者<code>file</code> 命令。</p>
        <h3>2.4.1 方式1</h3>
        <p>在CMake中使用<code>aux_source_directory</code> 命令可以查找某个路径下的<code>所有源文件</code> ，命令格式为：</p>
        <pre><code class="language-bash">aux_source_directory(&lt; dir &gt; &lt; variable &gt;)
</code></pre>
        <ul>
          <li><code>dir</code> ：要搜索的目录</li>
          <li><code>variable</code> ：将<code>dir</code> 目录下搜索到的源文件列表存储到该变量中</li>
        </ul>
        <pre><code class="language-bash">cmake_minimum_required(VERSION 3.0)
project(CALC)
include_directories(${PROJECT_SOURCE_DIR}/include)
# 搜索 src 目录下的源文件
aux_source_directory(${CMAKE_CURRENT_SOURCE_DIR}/src SRC_LIST)
add_executable(app  ${SRC_LIST})
</code></pre>
        <h3>2.4.2 方式2</h3>
        <p>在CMake中使用<code>file</code> 命令</p>
        <pre><code class="language-bash">file(GLOB/GLOB_RECURSE 变量名 要搜索的文件路径和文件类型)
</code></pre>
        <ul>
          <li><code>GLOB</code> ：将指定目录下搜索到的满足条件的所有文件生成一个列表，并将其存储到变量中</li>
          <li><code>CLOB_RECURSE</code> ：递归搜索指定目录，将搜索到的满足条件的文件名生成一个列表，并将其存储到变量中。</li>
        </ul>
        <pre><code class="language-bash">file(GLOB MAIN_SRC ${CMAKE_CURRENT_SOURCE_DIR}/src/*.cpp)
file(GLOB MAIN_HEAD ${CMAKE_CURRENT_SOURCE_DIR}/include/*.h)
</code></pre>
        <h2>2.5 包含头文件</h2>
        <p>在编译项目源文件时，很多时候都需要将源文件对应的头文件路径指定出来，这样才能保证在编译的过程中编译器能够找到这些头文件，并顺利通过编译。在CMake中设置要包含的目录也很简单，通过一个命令就可以搞定：</p>
        <pre><code class="language-bash">include_directories(headpath)
</code></pre>
        <h2>2.6 制作动态库或静态库</h2>
        <p>有时候编写的源代码并不需要将他们编译生成可执行程序，而是生成一些静态库或动态库提供给第三方使用，下面是在cmake中生成这两类库的方法。</p>
        <h3>2.6.1 制作静态库</h3>
        <p>在cmake中，如果要制作静态库，需要使用的命令如下：</p>
        <pre><code class="language-bash">add_library(库名称 STATIC 源文件1 [源文件2] ...)
</code></pre>
        <p>在Linux中，静态库名字分为三部分：<code>lib</code> + <code>库名字</code> + <code>.a</code> ，此处只需要指定出库的名字就可以了，另外两部分在生成该文件的时候会自动填充。</p>
        <p>在Windows中虽然库名和Linux格式不同，但也只需要指定出名字即可。</p>
        <p>下面有个一目录，需要将<code>src</code> 目录中源文件编译成静态库，然后再使用;</p>
        <pre><code class="language-bash">.
├── build
├── CMakeLists.txt
├── include           # 头文件目录
│   └── head.h
├── main.cpp          # 用于测试的源文件
└── src               # 源文件目录
    ├── add.cpp
    ├── div.cpp
    ├── mult.cpp
    └── sub.cpp
</code></pre>
        <p>根据上面的目录结构，可以这样编写<code>CMakeLists.txt</code> 文件：</p>
        <pre><code class="language-bash">cmake_minimum_required(VERSION 3.0)
project(CALC)
include_directories(${PROJECT_SOURCE_DIR}/include)
file(GLOB SRC_LIST "${CMAKE_CURRENT_SOURCE_DIR}/src/*.cpp")
add_library(calc STATIC ${SRC_LIST})
</code></pre>
        <p>这样最终就会生成对应的静态库文件<code>libcalc.a</code> 。</p>
        <h3>2.6.2 制作动态库</h3>
        <p>在cmake中，如果要制作动态库，需要使用的命令如下：</p>
        <pre><code class="language-bash">add_library(库名称 SHARED 源文件1 [源文件2] ...)
</code></pre>
        <p>在Linux中，动态库名字分为三部分：<code>lib</code> + <code>库名字</code> + <code>.so</code> ，此处只需要指定出库的名字就可以了，另外两部分在生成该文件的时候会自动填充。</p>
        <p>在Windows中虽然库名和Linux格式不同，但也只需要指定出名字即可。</p>
        <p>根据上面的目录结构，可以这样编写<code>CMakeLists.txt</code> 文件;</p>
        <pre><code class="language-bash">cmake_minimum_required(VERSION 3.0)
project(CALC)
include_directories(${PROJECT_SOURCE_DIR}/include)
file(GLOB SRC_LIST "${CMAKE_CURRENT_SOURCE_DIR}/src/*.cpp")
add_library(calc SHARED ${SRC_LIST})
</code></pre>
        <p>这样最终会生成对应的动态库文件<code>libcalc.so</code>。</p>
        <h3>2.6.3 指定输出的路径</h3>
        <p><strong>方式1- 适用于动态库</strong></p>
        <p>对于生成的库文件来说和可执行程序一样都可以指定输出路径。<code>由于在Linux系统下生成的动态库默认是有执行权限的</code> ，所以可以按照生成可执行程序的方式去指定它生成的目录：</p>
        <pre><code class="language-bash">cmake_minimum_required(VERSION 3.0)
project(CALC)
include_directories(${PROJECT_SOURCE_DIR}/include)
file(GLOB SRC_LIST "${CMAKE_CURRENT_SOURCE_DIR}/src/*.cpp")
# 设置动态库生成路径
set(EXECUTABLE_OUTPUT_PATH ${PROJECT_SOURCE_DIR}/lib)
add_library(calc SHARED ${SRC_LIST})
</code></pre>
        <p>对于这种方式来说，其实就是通过<code>set</code> 命令给<code>EXECUTABLE_OUTPUT_PATH</code> 宏设置了一个路径，这个路径就是可执行文件生成的路径。</p>
        <p><strong>方式2-都适用</strong></p>
        <p>由于在Linux下生成的静态库默认不具有可执行权限，所以在指定静态库生成的路径的时候就不能使用<code>EXECUTABLE_OUTPUT_PATH</code> 宏了，而应该使用<code>LIBRARY_OUTPUT_PATH</code> ，这个宏对应静态库文件和动态库文件都适用。</p>
        <pre><code class="language-bash">cmake_minimum_required(VERSION 3.0)
project(CALC)
include_directories(${PROJECT_SOURCE_DIR}/include)
file(GLOB SRC_LIST "${CMAKE_CURRENT_SOURCE_DIR}/src/*.cpp")
# 设置动态库/静态库生成路径
set(LIBRARY_OUTPUT_PATH ${PROJECT_SOURCE_DIR}/lib)
# 生成动态库
#add_library(calc SHARED ${SRC_LIST})
# 生成静态库
add_library(calc STATIC ${SRC_LIST})
</code></pre>
        <h2>2.7 包含库文件</h2>
        <p>在编写程序的过程中，可能会用到一些系统提供的动态库或者自己制作的出的动态库或者静态库，cmake中也为我们提供了相关的加载动态库的命令</p>
        <h3>2.7.1 链接静态库</h3>
        <p>在cmkae中，链接静态库的命令如下：</p>
        <pre><code class="language-bash">link_libraries(&lt;static lib&gt; [&lt;static lib&gt;...])
</code></pre>
        <ul>
          <li><strong><strong><strong>参数1</strong></strong></strong>：指定要链接的静态库的名字
            <ul>
              <li>可以是全名<code>libxxx.a</code></li>
              <li>也可以是掐头（<code>lib</code>）去尾（<code>.a</code>）之后的名字<code>xxx</code></li>
            </ul>
          </li>
          <li><strong>参数2-N</strong>：要链接的其它静态库的名字</li>
        </ul>
        <p>如果该静态库不是系统提供的（自己制作或者使用第三方提供的静态库）可能出现静态库找不到的情况，此时可以将静态库的路径也指定出来：</p>
        <pre><code class="language-bash">link_directories(&lt;lib path&gt;)
</code></pre>
        <h3>2.7.2 链接动态库</h3>
        <p>在程序编写过程中，除了在项目中引入静态库，好多时候也会使用一些标准的或者第三方提供的一些动态库。在<code>cmake</code> 中链接动态库的命令如下：</p>
        <pre><code class="language-bash">target_link_libraries(
    &lt;target&gt; 
    &lt;PRIVATE|PUBLIC|INTERFACE&gt; &lt;item&gt;... 
    [&lt;PRIVATE|PUBLIC|INTERFACE&gt; &lt;item&gt;...]...)
</code></pre>
        <ul>
          <li><code>target</code> ：指定要加载动态库的文件的名字
            <ul>
              <li>该文件可能是一个源文件</li>
              <li>该文件可能是一个动态库文件</li>
              <li>该文件可能是一个可执行文件</li>
            </ul>
          </li>
          <li><strong><strong><strong><strong><strong><strong><strong><strong>PRIVATE | PUBLIC | INTERFACE</strong></strong></strong></strong></strong></strong></strong></strong> ：动态库的访问权限，默认为<code>PUBLIC</code>
            <ul>
              <li>
                <p>如果各个动态库之间没有依赖关系，无需做任何设置，三者没有区别，一般无需指定，使用默认的PUBLIC即可。</p>
              </li>
              <li>
                <p><code>动态库的链接具有传递性</code> ，如果动态库A链接了动态库B、C，动态库连接了A，此时动态库D相当于也连接了动态库B、C，并可以使用动态库B、C中定义的方法。</p>
                <pre><code class="language-bash">target_link_libraries(A B C)
target_link_libraries(D A)
</code></pre>
              </li>
              <li>
                <p><code>PUBLIC</code> ：在public后面的库会被Link到前面的target中，并且里面的符号也会被导出，提供给第三方使用。</p>
              </li>
              <li>
                <p><code>PRIVATE</code> ：在private后面的库仅被link到前面的库中，并且终结掉，第三方不能感知到你调用了什么库。</p>
              </li>
              <li>
                <p><code>INTERFACE</code> ：在interface后面的库不会被连接到前面的target中，只会导出符号。</p>
              </li>
            </ul>
          </li>
        </ul>
        <p><strong><strong><strong>链接系统动态库</strong></strong></strong></p>
        <p>动态库的链接和静态库是完全不同的：</p>
        <ul>
          <li>静态库会生成可执行程序的链接阶段被打包到可执行程序中，所以可执行程序启动，静态库就被加载到内存中了。</li>
          <li>动态库在生成可执行程序的链接阶段不会被打包到可执行程序中，当可执行程序被启动并且调用了动态库中的函数的时候，动态库才会加载到内存</li>
        </ul>
        <p>因此，在<code>cmake</code> 中指定要链接的动态库的时候，<code>应该将命令写到生成了可执行文件之后：</code></p>
        <pre><code class="language-bash">cmake_minimum_required(VERSION 3.0)
project(TEST)
file(GLOB SRC_LIST ${CMAKE_CURRENT_SOURCE_DIR}/*.cpp)
# 添加并指定最终生成的可执行程序名
add_executable(app ${SRC_LIST})
# 指定可执行程序要链接的动态库名字
target_link_libraries(app pthread)
</code></pre>
        <p>在<code>target_link_libraries(app pthread)</code> 中：</p>
        <ul>
          <li><code>app</code> ：对应的是最终生成的可执行程序的名字</li>
          <li><code>pthread</code> ：这是可执行程序要加载的动态库，这个库是系统提供的线程库，全名为<code>libpthread.so</code></li>
        </ul>
        <p><strong><strong><strong>链接第三方动态库</strong></strong></strong></p>
        <p>现在，自己生成了一个动态库，对应的目录结构如下：</p>
        <pre><code class="language-bash">$ tree 
.
├── build
├── CMakeLists.txt
├── include
│   └── head.h            # 动态库对应的头文件
├── lib
│   └── libcalc.so        # 自己制作的动态库文件
└── main.cpp              # 测试用的源文件

3 directories, 4 files
</code></pre>
        <p>假设在测试文件<code>main.cpp</code> ：中既使用了自己制作的动态库<code>libcalc.so</code> 又使用了系统提供的线程库，此时<code>CMakeLists.txt</code> 文件可以这样写：</p>
        <pre><code class="language-makefile">cmake_minimum_required(VERSION 3.0)
project(TEST)
file(GLOB SRC_LIST ${CMAKE_CURRENT_SOURCE_DIR}/*.cpp)
# 指定源文件或者动态库对应的头文件路径
include_directories(${PROJECT_SOURCE_DIR}/include)
# 指定要链接的动态库的路径
link_directories(${PROJECT_SOURCE_DIR}/lib)
# 添加并生成一个可执行程序
add_executable(app ${SRC_LIST})
# 指定要链接的动态库
target_link_libraries(app pthread calc)
</code></pre>
        <h2>2.8 日志</h2>
        <p>在CMake中可以用用户显示一条消息，该命令的名字为<code>message</code> ：</p>
        <pre><code class="language-makefile">message([STATUS|WARNING|AUTHOR_WARNING|FATAL_ERROR|SEND_ERROR] "message to display" ...)
</code></pre>
        <ul>
          <li><code>（无）</code>：重要消息</li>
          <li><code>STATUS</code> ：非重要消息</li>
          <li><code>WARNING</code> ：CMake 警告，会继续执行</li>
          <li><code>AUTHOR_WARNING</code> ：CMake警告（dev），会继续执行</li>
          <li><code>SEND_ERROR</code>：CMake 错误，继续执行，但是会跳过生成的步骤</li>
          <li><code>FATAL_ERROR</code>：CMake 错误，终止所有处理过程</li>
        </ul>
        <p>CMake的命令行工具会在stdout上显示<code>STATUS</code> 消息，在stderr上显示其它消息。CMake的GUI会在它的log区域显示所有消息。</p>
        <p>CMake警告和错误消息的文本显示使用的是一种简单的标记语言。文本没有缩进，超过长度的行会回卷，段落之间以新行作为分隔符。</p>
        <pre><code class="language-makefile"># 输出一般日志信息
message(STATUS "source path: ${PROJECT_SOURCE_DIR}")
# 输出警告信息
message(WARNING "source path: ${PROJECT_SOURCE_DIR}")
# 输出错误信息
message(FATAL_ERROR "source path: ${PROJECT_SOURCE_DIR}")
</code></pre>
        <h2>2.9 变量追加</h2>
        <h3>2.9.1 追加</h3>
        <p>有时候项目中的源文件并不一定都在同一个目录中，但是这些源文件最终却需要一起进行编译来生成最终的可执行文件或者库文件。如果我们通过<code>fiel</code> 命令对各个目录下的源文件进行搜索，最后还需要做一个字符串拼接的操作，关于字符串拼接可以使用<code>set</code> 命令也可以使用<code>list</code> 命令。</p>
        <ol>
          <li>
            <p><strong>使用set拼接</strong></p>
            <p>如果使用set进行字符串拼接，对应的命令格式如下：</p>
            <pre><code class="language-makefile">set(变量名 ${变量名1} ${变量名2} ...)
</code></pre>
            <p>关于上面的命令其实就是将从第二个参数开始往后所有的字符串进行拼接，最后将结果存储到第一个参数中，如果第一个参数中原来有数据会对原数据就行覆盖。</p>
          </li>
          <li>
            <p><strong>使用list拼接</strong></p>
          </li>
        </ol>
        <p>如果使用list进行字符串拼接，对应的命令格式如下：</p>
        <pre><code class="language-makefile">list(APPEND &lt;list&gt; [&lt;element&gt; ...])
</code></pre>
        <p><code>list</code> 命令的功能比<code>set</code> 要强大，字符串拼接只是它的其中一个功能，所以需要在它第一个参数的位置指定出我们要做的操作，<code>APPEND</code> 表示进行数据追加，后边的参数和<code>set</code> 就一样了。</p>
        <pre><code class="language-makefile">cmake_minimum_required(VERSION 3.0)
project(TEST)
set(TEMP "hello,world")
file(GLOB SRC_1 ${PROJECT_SOURCE_DIR}/src1/*.cpp)
file(GLOB SRC_2 ${PROJECT_SOURCE_DIR}/src2/*.cpp)
# 追加(拼接)
list(APPEND SRC_1 ${SRC_1} ${SRC_2} ${TEMP})
message(STATUS "message: ${SRC_1}")
</code></pre>
        <p>在CMake中，使用<code>set</code> 命令可以创建一个<code>list</code> 。一个<code>list</code> 内部是一个由<code>分号；</code> 分割的一组字符串。例如，<code>set（var a b c d e）</code> 命令将会去创建一个<code>list：a;b;c;d;e</code> ，但是最终打印变量值的时候得到的是<code>abcde</code> 。</p>
        <pre><code class="language-makefile">set(tmp1 a;b;c;d;e)
set(tmp2 a b c d e)
message(${tmp1})
message(${tmp2})

##### 输出结果
abcde
abcde
</code></pre>
        <h3>2.9.2 字符串移除</h3>
        <p>我们在通过<code>file</code> 搜索某个目录就得到了该目录下所有的源文件，但是其中有些源文件并不是我们所需要的，比如：</p>
        <pre><code class="language-makefile">$ tree
.
├── add.cpp
├── div.cpp
├── main.cpp
├── mult.cpp
└── sub.cpp

0 directories, 5 files
</code></pre>
        <p>在当前的目录有五个源文件，其中<code>main.cpp</code> 是一个测试文件。如果我们想要把计算器相关的源文件生成一个动态库给别人使用，那么只需要<code>add.cpp、div.cpp、mult.cpp、sub.cpp</code> 这四个源文件就可以了。此时就需要将<code>mian.cpp</code> 从搜索到的数据中剔除出去，想要实现这个功能，也可以使用<code>list</code></p>
        <pre><code class="language-makefile">list(REMOVE_ITEM &lt;list&gt; &lt;value&gt; [&lt;value&gt; ...])
</code></pre>
        <p>关于<code>list</code> 命令还有其他功能</p>
        <ul>
          <li>
            <p>获取list的长度</p>
            <pre><code class="language-makefile">list(LENGTH &lt;list&gt; &lt;output variable&gt;)
</code></pre>
            <ul>
              <li><code>LENGTH</code> ：子命令LENGTH用于读取列表的长度</li>
              <li><code>&lt;list&gt;</code> ：当前操作的列表</li>
              <li><code>&lt;output variable&gt;</code> ：新创建的变量，用于存储列表的长度</li>
            </ul>
          </li>
          <li>
            <p>读取列表中指定索引的元素，可以指定多个索引</p>
            <pre><code class="language-makefile">list(GET &lt;list&gt; &lt;element index&gt; [&lt;element index&gt; ...] &lt;output variable&gt;)
</code></pre>
            <ul>
              <li><code>&lt;list&gt;</code> ：当前操作的列表</li>
              <li><code>&lt;element index&gt;</code> ：列表元素的索引
                <ul>
                  <li>从0开始编号，索引0的元素为列表中的第一个元素；</li>
                  <li>索引也可以是负数，<code>-1</code> 表示列表的最后一个元素，<code>-2</code> 表示列表倒数第二个元素，以此类推</li>
                  <li>当索引（不管是正还是负）超过列表的长度，运行会报错</li>
                </ul>
              </li>
              <li><code>&lt;output variable&gt;</code> ：新创建的变量，存储指定索引元素的返回结果，也是一个列表</li>
            </ul>
          </li>
          <li>
            <p>将列表中的元素用连接符（字符串）连接起来组成一个字符串</p>
            <pre><code class="language-makefile">list (JOIN &lt;list&gt; &lt;glue&gt; &lt;output variable&gt;)
</code></pre>
            <ul>
              <li><code>&lt;list&gt;</code> ：当前操作的列表</li>
              <li><code>&lt;glue&gt;</code> ：指定的连接符（字符串）</li>
              <li><code>&lt;output variable&gt;</code> ：新创建的变量，存储返回的字符串</li>
            </ul>
          </li>
          <li>
            <p>查找指定列表是否存在指定的元素，如果未找到，返回-1</p>
            <pre><code class="language-makefile">list(FIND &lt;list&gt; &lt;value&gt; &lt;output variable&gt;)
</code></pre>
            <ul>
              <li><code>&lt;list&gt;</code> ：当前操作的列表</li>
              <li><code>&lt;value&gt;</code> ：需要在列表中搜索的元素</li>
              <li><code>&lt;output variable&gt;</code> ：新创建的变量
                <ul>
                  <li>如果<code>&lt;list&gt;</code> 中存在<code>&lt;value&gt;</code> ，那么返回<code>&lt;value&gt;</code> 在列表中的索引</li>
                  <li>如果未找到则返回-1</li>
                </ul>
              </li>
            </ul>
          </li>
          <li>
            <p>将元素追加到列表中</p>
            <pre><code class="language-makefile">list (APPEND &lt;list&gt; [&lt;element&gt; ...])list (APPEND &lt;list&gt; [&lt;element&gt; ...])
</code></pre>
          </li>
          <li>
            <p>在list中指定位置插入若干元素</p>
            <pre><code class="language-makefile">list(INSERT &lt;list&gt; &lt;element_index&gt; &lt;element&gt; [&lt;element&gt; ...])
</code></pre>
          </li>
          <li>
            <p>将元素插入到列表的0索引位置</p>
            <pre><code class="language-makefile">list (PREPEND &lt;list&gt; [&lt;element&gt; ...])
</code></pre>
          </li>
          <li>
            <p>将列表中最后元素移除</p>
            <pre><code class="language-makefile">list (POP_BACK &lt;list&gt; [&lt;out-var&gt;...])
</code></pre>
          </li>
          <li>
            <p>将列表中第一个元素移除</p>
            <pre><code class="language-makefile">list (POP_FRONT &lt;list&gt; [&lt;out-var&gt;...])
</code></pre>
          </li>
          <li>
            <p>将指定的元素从列表中移除</p>
            <pre><code class="language-makefile">list (REMOVE_ITEM &lt;list&gt; &lt;value&gt; [&lt;value&gt; ...])
</code></pre>
          </li>
          <li>
            <p>将指定索引的元素从列表中移除</p>
            <pre><code class="language-makefile">list (REMOVE_AT &lt;list&gt; &lt;index&gt; [&lt;index&gt; ...])
</code></pre>
          </li>
          <li>
            <p>移除列表中的重复元素</p>
            <pre><code class="language-makefile">list (REMOVE_DUPLICATES &lt;list&gt;)
</code></pre>
          </li>
          <li>
            <p>列表翻转</p>
            <pre><code class="language-makefile">list(REVERSE &lt;list&gt;)
</code></pre>
          </li>
          <li>
            <p>列表排序</p>
            <pre><code class="language-makefile">list (SORT &lt;list&gt; [COMPARE &lt;compare&gt;] [CASE &lt;case&gt;] [ORDER &lt;order&gt;])
</code></pre>
            <ul>
              <li><code>COMPARE</code> ：指定排序方法，有如下几种可选：
                <ul>
                  <li><code>STRING</code> ：安装字母顺序进行排序，为默认的排序方法</li>
                  <li><code>FILE_BASENAME</code> ：如果是一系列路径名，会使用basename进行排序</li>
                  <li><code>NATURAL</code> ：使用自然数顺序排序</li>
                </ul>
              </li>
              <li><code>CASE</code> ：指明是否大小写敏感，有如下几种值可选
                <ul>
                  <li><code>SENSITIVE</code> ：按照大小写敏感的方式进行排序，为默认值</li>
                  <li><code>INSENSITIVE</code> ：按照大小写不敏感方式进行排序</li>
                </ul>
              </li>
              <li><code>ORDER</code> ：指明排序的顺序。有如下几种值可选：
                <ul>
                  <li><code>ASCENDING</code> ：按照升序排列，为默认值</li>
                  <li><code>DESCENDING</code> ：按照降序排列</li>
                </ul>
              </li>
            </ul>
          </li>
        </ul>
        <h2>2.10 宏定义</h2>
        <p>在进行程序测试的时候，我们可以在代码中添加一些宏定义，通过这些宏定义来控制这些代码是否生效，如下所示：</p>
        <pre><code class="language-makefile">#include &lt;stdio.h&gt;
#define NUMBER  3

int main()
{
    int a = 10;
#ifdef DEBUG
    printf("我是一个程序猿, 我不会爬树...\n");
#endif
    for(int i=0; i&lt;NUMBER; ++i)
    {
        printf("hello, GCC!!!\n");
    }
    return 0;
}
</code></pre>
        <p>在程序的第七行对<code>DEBUG</code> 宏进行了判断，如果该宏被定义了，那么第八行就会进行日志输出，如果没有定义这个宏，第八行就相当于被注释掉了，因此最终无法看到日志输出（上述代码中没有定义这个宏）</p>
        <p>为了让测试更灵活，我们可以不在代码中定义这个宏，而是在测试的时候把它定义出来，其中一种方式就是在<code>gcc/g++</code> 命令中去指定，如下：</p>
        <pre><code class="language-makefile">$ gcc test.c -DDEBUG -o app
</code></pre>
        <p>在<code>gcc/g++</code> 命令中通过参数<code>-D</code> 指定出要定义的宏的名字，这样就相当于在代码中定义了一个宏，其名字为<code>DEBUG</code> 。</p>
        <p>在<code>CMake</code> 中也可以做类似的事情，类似的命令叫做<code>add_definitions</code> ：</p>
        <pre><code class="language-makefile">add_definitions(-D宏名称)
</code></pre>
        <p>针对于上面的源文件编写一个<code>CMakeLists.txt</code>，内容如下：</p>
        <pre><code class="language-makefile">cmake_minimum_required(VERSION 3.0)
project(TEST)
# 自定义 DEBUG 宏
add_definitions(-DDEBUG)
add_executable(app ./test.c)
</code></pre>
        <p>通过这种方式，上述代码中的第八行日志就能够被输出出来了。</p>
        <h1>3.预定义宏</h1>
        <table>
          <thead>
            <tr>
              <th>宏</th>
              <th>功能</th>
            </tr>
          </thead>
          <tbody>
            <tr>
              <td>PROJECT_SOURCE_DIR</td>
              <td>使用 cmake 命令后紧跟的目录，一般是工程的根目录</td>
            </tr>
            <tr>
              <td>PROJECT_BINARY_DIR</td>
              <td>执行 cmake 命令的目录</td>
            </tr>
            <tr>
              <td>CMAKE_CURRENT_SOURCE_DIR</td>
              <td>当前处理的 CMakeLists.txt 所在的路径</td>
            </tr>
            <tr>
              <td>CMAKE_CURRENT_BINARY_DIR</td>
              <td>target 编译目录</td>
            </tr>
            <tr>
              <td>EXECUTABLE_OUTPUT_PATH</td>
              <td>重新定义目标二进制可执行文件的存放位置</td>
            </tr>
            <tr>
              <td>LIBRARY_OUTPUT_PATH</td>
              <td>重新定义目标链接库文件的存放位置</td>
            </tr>
            <tr>
              <td>PROJECT_NAME</td>
              <td>返回通过 PROJECT 指令定义的项目名称</td>
            </tr>
            <tr>
              <td>CMAKE_BINARY_DIR</td>
              <td>项目实际构建路径，假设在 build 目录进行的构建，那么得到的就是这个目录的路径</td>
            </tr>
          </tbody>
        </table>
        <h1>4.嵌套的CMake</h1>
        <p>如果项目很大，或者项目中有很多源码目录，在通过CMake管理项目的时候如果只使用一个<code>CMakeLists.txt</code>，那么这个文件相对会比较复杂，有一种化繁为简的方式就是给每个源码目录都添加一个<code>CMakeLists.txt</code>文件（头文件目录不需要），这样每个文件都不会太复杂，而且更灵活，更容易维护。
          先来看一下下面的目录：</p>
        <pre><code>$ tree
.
├── build
├── calc
│&nbsp;&nbsp; ├── add.cpp
│&nbsp;&nbsp; ├── CMakeLists.txt
│&nbsp;&nbsp; ├── div.cpp
│&nbsp;&nbsp; ├── mult.cpp
│&nbsp;&nbsp; └── sub.cpp
├── CMakeLists.txt
├── include
│&nbsp;&nbsp; ├── calc.h
│&nbsp;&nbsp; └── sort.h
├── sort
│&nbsp;&nbsp; ├── CMakeLists.txt
│&nbsp;&nbsp; ├── insert.cpp
│&nbsp;&nbsp; └── select.cpp
├── test1
│&nbsp;&nbsp; ├── calc.cpp
│&nbsp;&nbsp; └── CMakeLists.txt
└── test2
    ├── CMakeLists.txt
    └── sort.cpp

6 directories, 15 files
</code></pre>
        <ul>
          <li><code>include 目录</code>：头文件目录</li>
        </ul>
        <ul>
          <li><code>calc 目录</code> ：目录中的四个源文件对应的加减乘除算法
            <ul>
              <li>对应的头文件是<code>include</code> 中的<code>calc.h</code></li>
            </ul>
          </li>
          <li><code>sort 目录</code> ：目录中的两个源文件对应的是插入排序和选择排序算法
            <ul>
              <li>对应的头文件是<code>include</code> 中的<code>sort.h</code></li>
            </ul>
          </li>
          <li><code>test1 目录</code> ：测试目录，对加减乘除算法进行测试</li>
          <li><code>test2 目录</code> ：测试目录，对排序算法进行测试</li>
        </ul>
        <p>可以看到各个源文件目录所需要的<code>CMakeLists.txt</code> 文件现在已经添加完毕了。</p>
        <h2>4.1 准备工作</h2>
        <h3>4.1.1 节点关系</h3>
        <p>总所周知，Linux的目录是树状结构，所以<code>嵌套的CMake也是一个树状结构，最顶层的CMakeLists.txt是根节点，其次都是子节点</code> 。因此，我们需要了解一些关于<code>CMakeLists.txt</code> 文件变量作用域的一些信息：</p>
        <ul>
          <li>根节点<code>CMakeLists.txt</code> 中的变量全局有效</li>
          <li>父节点<code>CMakeLists.txt</code> 中的变量可以再子节点中使用</li>
          <li>子节点<code>CMakeLists.txt</code> 中的变量只能在当前节点中使用</li>
        </ul>
        <h3>4.1.2 添加子目录</h3>
        <p>接下来我们还需要知道在CMake中父子节点之间的关系是如何建立的，这里需要用到一个CMake命令：</p>
        <pre><code class="language-makefile">add_subdirectory(source_dir [binary_dir] [EXCLUDE_FROM_ALL])
</code></pre>
        <ul>
          <li><code>source_dir</code> ：指定了<code>CMakeLists.txt</code> 源文件和代码文件的位置，其实就是指定子目录</li>
          <li><code>binary_dir</code> ：指定了输出文件的路径，一般不需要指定，忽略即可。</li>
          <li><code>EXCLUDE_FROM_ALL</code> ：在子路径下的目标默认不会被包含到父路径的<code>ALL</code> 目标里，并且也会被排除在IDE工程文件之外。用户必须显式构建在子路径下的目标。</li>
        </ul>
        <p>通过这种方式<code>CMakeLists.txt</code> 文件之间的父子关系就被构建出来了。</p>
        <h2>4.2 解决问题</h2>
        <p>在上面的目录中我们要做如下事情：</p>
        <ol>
          <li>通过<code>test1 目录</code> 中的测试文件进行计算器相关的测试</li>
          <li>通过<code>test2 目录</code> 中的测试文件进行排序相关的测试</li>
        </ol>
        <p>现在相当于是要进行模块化测试，对于<code>calc</code> 和<code>sort</code> 目录中的源文件来说，可以将它们显编译成库文件（可以是静态库也可以是动态库）然后再提供给测试文件使用即可。库文件的本质其实还是代码，只不过是从文本格式变成了二进制。</p>
        <h3>4.2.1 根目录</h3>
        <p>根目录中的<code>CMakeLists.txt</code> 文件内容如下：</p>
        <pre><code>cmake_minimum_required(VERSION 3.0)
project(test)
# 定义变量
# 静态库生成的路径
set(LIB_PATH ${CMAKE_CURRENT_SOURCE_DIR}/lib)
# 测试程序生成的路径
set(EXEC_PATH ${CMAKE_CURRENT_SOURCE_DIR}/bin)
# 头文件目录
set(HEAD_PATH ${CMAKE_CURRENT_SOURCE_DIR}/include)
# 静态库的名字
set(CALC_LIB calc)
set(SORT_LIB sort)
# 可执行程序的名字
set(APP_NAME_1 test1)
set(APP_NAME_2 test2)
# 添加子目录
add_subdirectory(calc)
add_subdirectory(sort)
add_subdirectory(test1)
add_subdirectory(test2)
</code></pre>
        <p>在根节点对应的文件中主要做了两件事情：<code>定义全局变量</code> 和<code>添加子目录</code> 。</p>
        <ul>
          <li>定义的全局变量主要是给子节点使用，目的是为了提高子节点中的<code>CMakeLists.txt</code> 文件的可读性和可维护性，避免冗余并降低出错的概率。</li>
          <li>一共添加了四个子目录，每个子目录中都有一个<code>CMakeLists.txt</code> 文件，这样他们的父子关系就被确定下来了。</li>
        </ul>
        <h3>4.2.2 calc目录</h3>
        <p>calc 目录中的<code>CMakeLists.txt</code> 文件内容如下：</p>
        <pre><code class="language-makefile">cmake_minimum_required(VERSION 3.0)
project(CALCLIB)
aux_source_directory(./ SRC)
include_directories(${HEAD_PATH})
set(LIBRARY_OUTPUT_PATH ${LIB_PATH})
add_library(${CALC_LIB} STATIC ${SRC})
</code></pre>
        <ul>
          <li>第3行<code>aux_source_directory</code> ：搜索当前目录（calc目录）下的所有源文件</li>
          <li>第4行<code>include_directory</code> ：包含头文件路径，<code>HEAD_PATH</code> 是在根节点文件中定义的</li>
          <li>第5行<code>set</code> ：设置库的生成路径，<code>LIB_PATH</code> 是在根节点文件中定义的</li>
          <li>第6行<code>add_library</code> ：生成静态库，静态库的名字<code>CALC_LIB</code> 是在根节点文件中定义的。</li>
        </ul>
        <h3>4.2.3 sort目录</h3>
        <p>sort目录中的<code>CMakeLists.txt</code> 文件内容如下：</p>
        <pre><code class="language-makefile">cmake_minimum_required(VERSION 3.0)
project(SORTLIB)
aux_source_directory(./ SRC)
include_directories(${HEAD_PATH})
set(LIBRARY_OUTPUT_PATH ${LIB_PATH})
add_library(${SORT_LIB} SHARED ${SRC})
</code></pre>
        <ul>
          <li>第6行<code>add_library</code> ：生成动态库，动态库名字<code>SORT_LIB</code> 是在根节点文件中定义的。</li>
        </ul>
        <p>这个文件中的内容和<code>calc</code> 节点文件中生成的内容类似，只不过这次生成的是动态库。</p>
        <h3>4.2.4 test1目录</h3>
        <p>test1目录中的<code>CMakeLists.txt</code> 文件内容如下：</p>
        <pre><code class="language-makefile">cmake_minimum_required(VERSION 3.0)
project(CALCTEST)
aux_source_directory(./ SRC)
include_directories(${HEAD_PATH})
# include_directories(${HEAD_PATH})
link_libraries(${CALC_LIB})
set(EXECUTABLE_OUTPUT_PATH ${EXEC_PATH})
add_executable(${APP_NAME_1} ${SRC})
</code></pre>
        <ul>
          <li>第4行<code>include_directories</code> ：指定头文件路径，<code>HEAD_PATH</code> 变量实在根节点文件中定义的</li>
          <li>第6行<code>link_libraries</code> ：指定可执行程序要链接<code>静态库</code> ，<code>CALC_LIB</code> 变量是在根节点文件中定义的</li>
          <li>第7行<code>set</code> ：指定可执行程序生成的路径，<code>EXEC_PATH</code> 变量是在根节点文件中定义的</li>
          <li>第8行<code>add_executable</code> ：生成可执行程序，<code>APP_NAME_1</code> 变量是在根节点文件中定义的</li>
        </ul>
        <p>此处的可执行程序连接的的静态库，最终静态库会被打包到可执行程序中，可执行程序启动之后，静态库也就随之被加载到内存中了。</p>
        <h3>4.2.5 test2目录</h3>
        <p>test2目录中的<code>CMakeLists.txt</code> 文件内容如下：</p>
        <pre><code class="language-makefile">cmake_minimum_required(VERSION 3.0)
project(SORTTEST)
aux_source_directory(./ SRC)
include_directories(${HEAD_PATH})
set(EXECUTABLE_OUTPUT_PATH ${EXEC_PATH})
# link_directories(${LIB_PATH})
add_executable(${APP_NAME_2} ${SRC})
target_link_libraries(${APP_NAME_2} ${SORT_LIB})
</code></pre>
        <ul>
          <li>第4行<code>include_directories</code> ：包含头文件路径，<code>HEAD_PATH</code> 变量是在根节点文件中定义的</li>
          <li>第5行<code>set</code> ：指定可执行程序生成的路径，<code>EXEC_PATH</code> 变量在根节点文件中定义的</li>
          <li>第6行<code>link_directories</code> ：指定可执行程序要链接的动态库的路径，<code>LIB_PATH</code> 变量是在根节点文件中定义的</li>
          <li>第7行<code>add_executable</code> ：生成可执行程序，<code>APP_NAME_2</code> 变量是在根节点文件中定义的</li>
          <li>第8行<code>target_link_libraries</code> ：指定可执行程序要链接的动态库的名字</li>
        </ul>
        <p>在生成可执行程序的时候，动态库不会被打包到可执行程序内部。当可执行程序启动之后动态库也不会被加载到内存，只有可执行程序调用了动态库中的函数的时候，动态库才会被加载到内存中，且多个进程可以共用内存中的同一个动态库，所以动态库又叫共享库。</p>
        <h3>4.2.6 构建项目</h3>
        <p>一切准备就绪之后，开始构建项目，进入到根节点目录的<code>build 目录</code> 中，执行<code>cmake 命令</code> ，如下：</p>
        <pre><code>$ cmake ..
-- The C compiler identification is GNU 5.4.0
-- The CXX compiler identification is GNU 5.4.0
-- Check for working C compiler: /usr/bin/cc
-- Check for working C compiler: /usr/bin/cc -- works
-- Detecting C compiler ABI info
-- Detecting C compiler ABI info - done
-- Detecting C compile features
-- Detecting C compile features - done
-- Check for working CXX compiler: /usr/bin/c++
-- Check for working CXX compiler: /usr/bin/c++ -- works
-- Detecting CXX compiler ABI info
-- Detecting CXX compiler ABI info - done
-- Detecting CXX compile features
-- Detecting CXX compile features - done
-- Configuring done
-- Generating done
-- Build files have been written to: /home/robin/abc/cmake/calc/build
</code></pre>
        <p>可以看到在build 目录中生成了一些文件和目录，如下所示：</p>
        <pre><code>$ tree build -L 1     
build
├── calc                  # 目录
├── CMakeCache.txt        # 文件
├── CMakeFiles            # 目录
├── cmake_install.cmake   # 文件
├── Makefile              # 文件
├── sort                  # 目录
├── test1                 # 目录
└── test2                 # 目录
</code></pre>
        <p>然后再<code>build</code> 目录下执行<code>make</code> 命令：</p>
        <ul>
          <li>在项目根目录的<code>lib</code> 目录中生成了静态库<code>libcalc.a</code></li>
          <li>在项目根目录的<code>lib</code> 目录中生成了动态库<code>libsort.so</code></li>
          <li>在项目根目录的<code>bin</code> 目录中生成了可执行程序<code>test1</code></li>
          <li>在项目根目录的<code>bin</code> 目录中生成了可执行程序<code>test2</code></li>
        </ul>
        <pre><code>$ tree bin/ lib/
bin/
├── test1
└── test2
lib/
├── libcalc.a
└── libsort.so
</code></pre>
        <p>在项目中，如果将程序中的某个模块制作成了动态库或者静态库并且在CMakeLists.txt 中指定了库的输出目录，而后其它模块又需要加载这个生成的库文件，此时直接使用就可以了，如果没有指定库的输出路径或者需要直接加载外部提供的库文件，此时就需要使用 link_directories 将库文件路径指定出来。</p>
        <h1>5.流程控制</h1>
        <p>在CMake的CMakeLists.txt中也可以进行流程控制，也就是说可以像shell脚本那样进行<code>条件判断</code> 和<code>循环</code> 。</p>
        <h2>5.1 条件判断</h2>
        <p>关于条件判断其语法格式如下：</p>
        <pre><code class="language-makefile">if(&lt;condition&gt;)
  &lt;commands&gt;
elseif(&lt;condition&gt;) # 可选快, 可以重复
  &lt;commands&gt;
else()              # 可选快
  &lt;commands&gt;
endif()
</code></pre>
        <p>在进行条件判断的时候，如果有多个条件，那么可以写多个<code>elseif</code> ，最后一个条件可以使用<code>else</code> ，但是开始和结束是必须要成对出现的，分别为：<code>if</code> 和<code>endif</code> 。</p>
        <h3>5.1.1 基本表达式</h3>
        <pre><code class="language-makefile">if(&lt;expression&gt;)
</code></pre>
        <p>如果是基本表达式，<code>expression</code> 有如下三种情况：<code>常亮</code> 、<code>变量</code> 、<code>字符串</code> 。</p>
        <ul>
          <li>如果是 <code>1</code> ， <code>ON</code> ， <code>YES</code> ， <code>TRUE</code>， <code>Y</code> ，<code>非零值</code>，<code>非空字符串</code>时，条件判断返回 <code>True</code></li>
          <li>如果是<code>0</code>， <code>OFF</code>， <code>NO</code>， <code>FALSE</code>， <code>N</code>， <code>IGNORE</code>， <code>NOTFOUND</code>，空字符串时，条件判断返回 <code>False</code></li>
        </ul>
        <h3>5.1.2 逻辑判断</h3>
        <ul>
          <li>
            <p>NOT</p>
            <pre><code class="language-makefile">if(NOT &lt;condition&gt;)
</code></pre>
            <p>其实这就是一个取反操作，如果条件<code>condition</code> 为<code>True</code> 将返回<code>False</code> ，如果条件<code>condition</code> 为<code>False</code> 将返回<code>True</code> 。</p>
          </li>
          <li>
            <p>AND</p>
            <pre><code class="language-makefile">if(&lt;cond1&gt; AND &lt;cond2&gt;)
</code></pre>
            <p>如果 <code>cond1</code> 和 <code>cond2</code> 同时为 <code>True</code>，返回 <code>True</code> 否则返回 <code>False</code>。</p>
          </li>
          <li>
            <p>OR</p>
            <pre><code class="language-makefile">if(&lt;cond1&gt; OR &lt;cond2&gt;)
</code></pre>
            <p>如果 <code>cond1</code> 和 <code>cond2</code> 两个条件中至少有一个为 <code>True</code>，返回 <code>True</code>，如果两个条件都为 <code>False</code> 则返回 <code>False</code>。</p>
          </li>
        </ul>
        <h3>5.1.3 比较</h3>
        <ul>
          <li>
            <p>基于数值的比较</p>
            <pre><code class="language-makefile">if(&lt;variable|string&gt; LESS &lt;variable|string&gt;)
if(&lt;variable|string&gt; GREATER &lt;variable|string&gt;)
if(&lt;variable|string&gt; EQUAL &lt;variable|string&gt;)
if(&lt;variable|string&gt; LESS_EQUAL &lt;variable|string&gt;)
if(&lt;variable|string&gt; GREATER_EQUAL &lt;variable|string&gt;)
</code></pre>
            <ul>
              <li><code>LESS</code> ：如果左侧数值<code>小于</code> 右侧，返回<code>True</code></li>
              <li><code>GREATER</code> ：如果左侧数值<code>大于</code> 右侧，返回<code>True</code></li>
              <li><code>EQUAL</code>：如果左侧数值<code>等于</code>右侧，返回 <code>True</code></li>
              <li><code>LESS_EQUAL</code>：如果左侧数值<code>小于等于</code>右侧，返回 <code>True</code></li>
              <li><code>GREATER_EQUAL</code>：如果左侧数值<code>大于等于</code>右侧，返回 <code>True</code></li>
            </ul>
          </li>
          <li>
            <p>基于字符串比较</p>
            <pre><code class="language-makefile">if(&lt;variable|string&gt; STRLESS &lt;variable|string&gt;)
if(&lt;variable|string&gt; STRGREATER &lt;variable|string&gt;)
if(&lt;variable|string&gt; STREQUAL &lt;variable|string&gt;)
if(&lt;variable|string&gt; STRLESS_EQUAL &lt;variable|string&gt;)
if(&lt;variable|string&gt; STRGREATER_EQUAL &lt;variable|string&gt;)
</code></pre>
            <ul>
              <li><code>STRLESS</code> ：如果左侧字符串<code>小于</code> 右侧，返回<code>True</code></li>
              <li><code>STRGREATER</code> ：如果左侧字符串<code>大于</code> 右侧，返回<code>True</code></li>
              <li><code>STREQUAL</code> ：如果左侧字符串<code>等于</code> 右侧，返回<code>True</code></li>
              <li><code>STRLESS_EQUAL</code> ：如果左侧字符串<code>小于等于</code> 右侧，返回<code>True</code></li>
              <li><code>STRGREATER_EQUAL</code> ：如果左侧字符串<code>大于等于</code> 右侧，返回<code>True</code></li>
            </ul>
          </li>
        </ul>
        <h3>5.1.4 文件操作</h3>
        <p>1、判断文件或者目录是否存在</p>
        <pre><code class="language-makefile">if(EXISTS path-to-file-or-directory)
</code></pre>
        <p>如果文件或者目录存在返回<code>True</code> ，否则返回<code>False</code></p>
        <p>2、判断是不是目录</p>
        <pre><code class="language-makefile">if(IS_DIRECTORY path)
</code></pre>
        <ul>
          <li>此处目录的path必须是绝对路径</li>
          <li>如果目录存在返回<code>True</code> ，目录不存在返回<code>False</code></li>
        </ul>
        <p>3、判断是不是软链接</p>
        <pre><code class="language-makefile">if(IS_SYMLINK file-name)
</code></pre>
        <ul>
          <li>此处的file-name对应的路径必须是绝对路径</li>
          <li>如果是软链接返回<code>True</code> ，软链接不存在则返回<code>False</code></li>
          <li>软链接相当于windows里的快捷方式</li>
        </ul>
        <p>4、判断是不是绝对路径</p>
        <pre><code class="language-makefile">if(IS_ABSOLUTE path)
</code></pre>
        <ul>
          <li>关于绝对路径
            <ul>
              <li>如果是<code>Linux</code> ，该路径需要从根目录开始描述</li>
              <li>如果是<code>Windows</code> ，该路径需要从盘符开始描述</li>
            </ul>
          </li>
          <li>如果是绝对路径返回<code>True</code> ，如果不是绝对路径返回<code>False</code></li>
        </ul>
        <h3>5.1.5 其它</h3>
        <ul>
          <li>
            <p>判断某个元素是否在列表中</p>
            <pre><code class="language-makefile">if(&lt;variable|string&gt; IN_LIST &lt;variable&gt;)
</code></pre>
            <ul>
              <li>如果这个元素在列表中返回<code>True</code></li>
            </ul>
          </li>
          <li>
            <p>比较两个路径是否相等</p>
            <pre><code class="language-makefile">if(&lt;variable|string&gt; PATH_EQUAL &lt;variable|string&gt;)
</code></pre>
            <p>我们在书写某个路径的时候，可能由于误操作会多写几个分隔符，比如把 <code>/a/b/c</code> 写成 <code>/a//b///c</code>，此时通过 <code>STREQUAL</code> 对这两个字符串进行比较肯定是不相等的，但是通过 <code>PATH_EQUAL</code> 去比较两个路径，得到的结果确实相等的</p>
          </li>
        </ul>
        <h2>5.2 循环</h2>
        <p>在CMake中循环有两种方式，分别是：<code>foreach</code> 和<code>while</code></p>
        <h3>5.2.1 foreach</h3>
        <p>使用foreach进行循环，语法格式如下：</p>
        <pre><code class="language-makefile">foreach(&lt;loop_var&gt; &lt;items&gt;)
    &lt;commands&gt;
endforeach()
</code></pre>
        <p>通过<code>foreach</code> 我们就可以对<code>items</code> 中的数据进行遍历，然后通过<code>loop_var</code> 将遍历到的当前的值取出，在取值的时候有以下几种方法</p>
        <p><strong><strong><strong>方法一：</strong></strong></strong></p>
        <pre><code class="language-makefile">foreach(&lt;loop_var&gt; RANGE &lt;stop&gt;)
</code></pre>
        <ul>
          <li><code>RANGE</code> ：关键字，表示要遍历范围</li>
          <li><code>stop</code> ：这是一个<code>正整数，表示范围的结束值</code> ，在遍历的时候<code>从0开始，最大值为stop</code> 。</li>
          <li><code>loop_var</code> ：存储每次循环取出的值</li>
        </ul>
        <p><strong><strong><strong>方法二：</strong></strong></strong></p>
        <pre><code class="language-makefile">foreach(&lt;loop_var&gt; RANGE &lt;start&gt; &lt;stop&gt; [&lt;step&gt;])
</code></pre>
        <p>这是上面<code>方法1</code> 的加强版，我们在遍历一个整数区间的时候，除了可以指定起始范围，还可以指定步长。</p>
        <ul>
          <li><code>RANGE</code> ：关键字，表示要遍历范围</li>
          <li><code>start</code> ：这是一个<code>正整数，表示范围的起始值，也就是说最小值为start</code></li>
          <li><code>stop</code> ：这是一个<code>正整数，表示范围的结束值，也就是说最大值为stop</code></li>
          <li><code>step</code> ：控制每次遍历的时候以怎样的步长增长，<code>默认为1，可以不设置</code></li>
          <li><code>loop_var</code> ：存储每次循环取出的值</li>
        </ul>
        <p><strong><strong>方法3</strong></strong></p>
        <pre><code class="language-makefile">foreach(&lt;loop_var&gt; IN [LISTS [&lt;lists&gt;]] [ITEMS [&lt;items&gt;]])
</code></pre>
        <p>这是<code>foreach</code> 的另一个变体，通过这种方式我们可以对更加复杂的数据进行遍历，前两种方式只适用于对某个正整数范围内的遍历。</p>
        <ul>
          <li><code>IN</code> ：关键字，表示在xxx里面</li>
          <li><code>LISTS</code> ：关键字，对应的是列表<code>list</code> ，通过<code>set、list</code> 可以获得</li>
          <li><code>ITEMS</code> ：关键字，对应的也是列表</li>
          <li><code>loop_var</code> ：存储每次循环取出的值</li>
        </ul>
        <p><strong><strong>方法4</strong></strong></p>
        <pre><code class="language-makefile">foreach(&lt;loop_var&gt;... IN ZIP_LISTS &lt;lists&gt;)
</code></pre>
        <p>通过这种方式，遍历的还是一个或多个列表，可以理解为是<code>方式3</code> 的加强版。因为通过上面的方式遍历多个列表，但是又想把指定列表中的元素取出来使用时做不到的，在这个加强版中就可以轻松实现。</p>
        <ul>
          <li><code>loop_var</code> ：存储每次循环取出的值，可以根据要遍历的列表的数量指定多个变量，用于存储对应的列表当前取出的那个值。
            <ul>
              <li><code>如果指定了多个变量名，他们的数量应该和列表的数量相等</code></li>
              <li><code>如果只给出了一个loop_var，那么它将一系列的loop_var_N 变量来存储对应列表中的当前项，也就是说loop_var_0 对应第一个列表，loop_var_1对应第二个列表，以此类推。。。。</code></li>
              <li><code>如果遍历的多个列表中一个列表较短，当它遍历完成之后将不会参与后续的遍历（因为其它列表还没有遍历完）</code></li>
            </ul>
          </li>
          <li><code>IN</code> ：关键字，表示在XXX里面</li>
          <li><code>ZIP_LISTS</code> ：关键字，对应的列表<code>list</code> ，通过<code>set、list</code> 可以获得</li>
        </ul>
        <h3>5.2.2 while</h3>
        <p>除了使用<code>foreach</code> 也可以使用<code>while</code> 进行循环，关于循环结束对应的条件判断的书写格式和<code>if/elseif</code> 是一样的。<code>while</code> 的语法格式如下：</p>
        <pre><code class="language-makefile">while(&lt;condition&gt;)
    &lt;commands&gt;
endwhile()
</code></pre>
      </div>
    </div>




    <footer class="site-footer">
      <div class="container">
        <p>© 2024 My Website. All rights reserved.</p>
        <ul class="footer-links">
          <li><a href="#">About Us</a></li>
          <li><a href="#">Privacy Policy</a></li>
          <li><a href="#">Contact Us</a></li>
        </ul>
      </div>
    </footer>


  </body>

</html>